{"ast":null,"code":"import * as Linking from \"expo-linking\";\nimport { resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nfunction assertIsReady(store) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\");\n  }\n}\nexport function push(url) {\n  return this.linkTo(resolveHref(url));\n}\nexport function replace(url) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\nexport function goBack() {\n  var _this$navigationRef, _this$navigationRef$c;\n  assertIsReady(this);\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : (_this$navigationRef$c = _this$navigationRef.current) == null ? void 0 : _this$navigationRef$c.goBack();\n}\nexport function canGoBack() {\n  var _this$navigationRef$c2, _this$navigationRef2, _this$navigationRef2$;\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return (_this$navigationRef$c2 = (_this$navigationRef2 = this.navigationRef) == null ? void 0 : (_this$navigationRef2$ = _this$navigationRef2.current) == null ? void 0 : _this$navigationRef2$.canGoBack()) != null ? _this$navigationRef$c2 : false;\n}\nexport function setParams() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.setParams.bind(_this$navigationRef3$))(params);\n}\nexport function linkTo(href, event) {\n  var _this = this;\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  if (href.startsWith(\".\")) {\n    var _this$routeInfo$segme, _this$routeInfo, _this$routeInfo$segme2;\n    var base = (_this$routeInfo$segme = (_this$routeInfo = this.routeInfo) == null ? void 0 : (_this$routeInfo$segme2 = _this$routeInfo.segments) == null ? void 0 : _this$routeInfo$segme2.map(function (segment) {\n      if (!segment.startsWith(\"[\")) return segment;\n      if (segment.startsWith(\"[...\")) {\n        var _this$routeInfo2, _this$routeInfo2$para;\n        segment = segment.slice(4, -1);\n        var params = (_this$routeInfo2 = _this.routeInfo) == null ? void 0 : (_this$routeInfo2$para = _this$routeInfo2.params) == null ? void 0 : _this$routeInfo2$para[segment];\n        if (Array.isArray(params)) {\n          return params.join(\"/\");\n        } else {\n          var _params$split$join, _params$split;\n          return (_params$split$join = params == null ? void 0 : (_params$split = params.split(\",\")) == null ? void 0 : _params$split.join(\"/\")) != null ? _params$split$join : \"\";\n        }\n      } else {\n        var _this$routeInfo3, _this$routeInfo3$para;\n        segment = segment.slice(1, -1);\n        return (_this$routeInfo3 = _this.routeInfo) == null ? void 0 : (_this$routeInfo3$para = _this$routeInfo3.params) == null ? void 0 : _this$routeInfo3$para[segment];\n      }\n    }).filter(Boolean).join(\"/\")) != null ? _this$routeInfo$segme : \"/\";\n    href = resolve(base + \"/..\", href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state || state.routes.length === 0) {\n    console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n    return;\n  }\n  switch (event) {\n    case \"REPLACE\":\n      return navigationRef.dispatch(getNavigateReplaceAction(state, rootState));\n    default:\n      return navigationRef.dispatch(getNavigatePushAction(state, rootState));\n  }\n}\nfunction rewriteNavigationStateToParams(state) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!state) return params;\n  var lastRoute = state.routes.at(-1);\n  params.screen = lastRoute.name;\n  params.params = lastRoute.params ? JSON.parse(JSON.stringify(lastRoute.params)) : {};\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n  return JSON.parse(JSON.stringify(params));\n}\nfunction getNavigatePushAction(state, rootState) {\n  var _rewriteNavigationSta = rewriteNavigationStateToParams(state),\n    screen = _rewriteNavigationSta.screen,\n    params = _rewriteNavigationSta.params;\n  return {\n    type: \"NAVIGATE\",\n    target: rootState.key,\n    payload: {\n      name: screen,\n      params: params\n    }\n  };\n}\nfunction getNavigateReplaceAction(state, parentState) {\n  var _lastNavigatorSupport;\n  var lastNavigatorSupportingReplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parentState;\n  var route = state.routes.at(-1);\n  if (parentState.type === \"stack\" || parentState.type === \"tab\") {\n    lastNavigatorSupportingReplace = parentState;\n  }\n  var currentRoute = parentState.routes.find(function (parentRoute) {\n    return parentRoute.name === route.name;\n  });\n  var routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n  if (route.state && routesAreEqual && currentRoute.state) {\n    return getNavigateReplaceAction(route.state, currentRoute.state, lastNavigatorSupportingReplace);\n  }\n  var _rewriteNavigationSta2 = rewriteNavigationStateToParams(state),\n    screen = _rewriteNavigationSta2.screen,\n    params = _rewriteNavigationSta2.params;\n  return {\n    type: lastNavigatorSupportingReplace.type === \"stack\" ? \"REPLACE\" : \"JUMP_TO\",\n    target: (_lastNavigatorSupport = lastNavigatorSupportingReplace) == null ? void 0 : _lastNavigatorSupport.key,\n    payload: {\n      name: screen,\n      params: params\n    }\n  };\n}","map":{"version":3,"names":["Linking","resolveHref","resolve","hasUrlProtocolPrefix","assertIsReady","store","navigationRef","isReady","Error","push","url","linkTo","replace","goBack","_this$navigationRef","_this$navigationRef$c","current","canGoBack","_this$navigationRef$c2","_this$navigationRef2","_this$navigationRef2$","setParams","_this$navigationRef3","_this$navigationRef3$","params","arguments","length","undefined","bind","href","event","_this","openURL","linking","rootState","getRootState","startsWith","_this$routeInfo$segme","_this$routeInfo","_this$routeInfo$segme2","base","routeInfo","segments","map","segment","_this$routeInfo2","_this$routeInfo2$para","slice","Array","isArray","join","_params$split$join","_params$split","split","_this$routeInfo3","_this$routeInfo3$para","filter","Boolean","state","getStateFromPath","config","routes","console","error","dispatch","getNavigateReplaceAction","getNavigatePushAction","rewriteNavigationStateToParams","lastRoute","at","screen","name","JSON","parse","stringify","_rewriteNavigationSta","type","target","key","payload","parentState","_lastNavigatorSupport","lastNavigatorSupportingReplace","route","currentRoute","find","parentRoute","routesAreEqual","index","_rewriteNavigationSta2"],"sources":["C:/Users/Bartek/react_native_boi/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import {\n  type NavigationAction,\n  type NavigationState,\n} from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\n\nimport { ResultState } from \"../fork/getStateFromPath\";\nimport { Href, resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nimport type { RouterStore } from \"./router-store\";\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      \"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\"\n    );\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number> = {}\n) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  if (href.startsWith(\".\")) {\n    const base =\n      this.routeInfo?.segments\n        ?.map((segment) => {\n          if (!segment.startsWith(\"[\")) return segment;\n\n          if (segment.startsWith(\"[...\")) {\n            segment = segment.slice(4, -1);\n            const params = this.routeInfo?.params?.[segment];\n            if (Array.isArray(params)) {\n              return params.join(\"/\");\n            } else {\n              return params?.split(\",\")?.join(\"/\") ?? \"\";\n            }\n          } else {\n            segment = segment.slice(1, -1);\n            return this.routeInfo?.params?.[segment];\n          }\n        })\n        .filter(Boolean)\n        .join(\"/\") ?? \"/\";\n\n    href = resolve(base + \"/..\", href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error(\n      \"Could not generate a valid navigation state for the given path: \" + href\n    );\n    return;\n  }\n\n  switch (event) {\n    case \"REPLACE\":\n      return navigationRef.dispatch(getNavigateReplaceAction(state, rootState));\n    default:\n      return navigationRef.dispatch(getNavigatePushAction(state, rootState));\n  }\n}\n\ntype NavigationParams = Partial<{\n  screen: string;\n  params: NavigationParams;\n}>;\n\nfunction rewriteNavigationStateToParams(\n  state?: { routes: ResultState[\"routes\"] },\n  params: NavigationParams = {}\n) {\n  if (!state) return params;\n  // We Should always have at least one route in the state\n  const lastRoute = state.routes.at(-1)!;\n  params.screen = lastRoute.name;\n  // Weirdly, this always needs to be an object. If it's undefined, it won't work.\n  params.params = lastRoute.params\n    ? JSON.parse(JSON.stringify(lastRoute.params))\n    : {};\n\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n\n  return JSON.parse(JSON.stringify(params));\n}\n\nfunction getNavigatePushAction(state: ResultState, rootState: NavigationState) {\n  const { screen, params } = rewriteNavigationStateToParams(state);\n  return {\n    type: \"NAVIGATE\",\n    target: rootState.key,\n    payload: {\n      name: screen,\n      params,\n    },\n  };\n}\n\nfunction getNavigateReplaceAction(\n  state: ResultState,\n  parentState: NavigationState,\n  lastNavigatorSupportingReplace: NavigationState = parentState\n): NavigationAction {\n  // We should always have at least one route in the state\n  const route = state.routes.at(-1)!;\n\n  // Only these navigators support replace\n  if (parentState.type === \"stack\" || parentState.type === \"tab\") {\n    lastNavigatorSupportingReplace = parentState;\n  }\n\n  const currentRoute = parentState.routes.find(\n    (parentRoute) => parentRoute.name === route.name\n  );\n  const routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n\n  // If there is nested state and the routes are equal, we should keep going down the tree\n  if (route.state && routesAreEqual && currentRoute.state) {\n    return getNavigateReplaceAction(\n      route.state,\n      currentRoute.state as any,\n      lastNavigatorSupportingReplace\n    );\n  }\n\n  // Either we reached the bottom of the state or the point where the routes diverged\n  const { screen, params } = rewriteNavigationStateToParams(state);\n\n  return {\n    type:\n      lastNavigatorSupportingReplace.type === \"stack\" ? \"REPLACE\" : \"JUMP_TO\",\n    target: lastNavigatorSupportingReplace?.key,\n    payload: {\n      name: screen,\n      params,\n    },\n  };\n}\n"],"mappings":"AAIA,OAAO,KAAKA,OAAO,MAAM,cAAc;AAGvC,SAAeC,WAAW;AAC1B,SAASC,OAAO;AAChB,SAASC,oBAAoB;AAG7B,SAASC,aAAaA,CAACC,KAAkB,EAAE;EACzC,IAAI,CAACA,KAAK,CAACC,aAAa,CAACC,OAAO,CAAC,CAAC,EAAE;IAClC,MAAM,IAAIC,KAAK,CACb,gKACF,CAAC;EACH;AACF;AAEA,OAAO,SAASC,IAAIA,CAAoBC,GAAS,EAAE;EACjD,OAAO,IAAI,CAACC,MAAM,CAACV,WAAW,CAACS,GAAG,CAAC,CAAC;AACtC;AAEA,OAAO,SAASE,OAAOA,CAAoBF,GAAS,EAAE;EACpD,OAAO,IAAI,CAACC,MAAM,CAACV,WAAW,CAACS,GAAG,CAAC,EAAE,SAAS,CAAC;AACjD;AAEA,OAAO,SAASG,MAAMA,CAAA,EAAoB;EAAA,IAAAC,mBAAA,EAAAC,qBAAA;EACxCX,aAAa,CAAC,IAAI,CAAC;EACnB,CAAAU,mBAAA,OAAI,CAACR,aAAa,sBAAAS,qBAAA,GAAlBD,mBAAA,CAAoBE,OAAO,qBAA3BD,qBAAA,CAA6BF,MAAM,CAAC,CAAC;AACvC;AAEA,OAAO,SAASI,SAASA,CAAA,EAA6B;EAAA,IAAAC,sBAAA,EAAAC,oBAAA,EAAAC,qBAAA;EAMpD,IAAI,CAAC,IAAI,CAACd,aAAa,CAACC,OAAO,CAAC,CAAC,EAAE;IACjC,OAAO,KAAK;EACd;EACA,QAAAW,sBAAA,IAAAC,oBAAA,GAAO,IAAI,CAACb,aAAa,sBAAAc,qBAAA,GAAlBD,oBAAA,CAAoBH,OAAO,qBAA3BI,qBAAA,CAA6BH,SAAS,CAAC,CAAC,YAAAC,sBAAA,GAAI,KAAK;AAC1D;AAEA,OAAO,SAASG,SAASA,CAAA,EAGvB;EAAA,IAAAC,oBAAA,EAAAC,qBAAA;EAAA,IADAC,MAAuC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAE5CrB,aAAa,CAAC,IAAI,CAAC;EACnB,OAAO,EAAAkB,oBAAA,GAAC,IAAI,CAAChB,aAAa,sBAAAiB,qBAAA,GAAlBD,oBAAA,CAAoBN,OAAO,qBAA3BO,qBAAA,CAA6BF,SAAS,CAAAO,IAAA,CAAAL,qBAAA,GAASC,MAAM,CAAC;AAChE;AAEA,OAAO,SAASb,MAAMA,CAAoBkB,IAAY,EAAEC,KAAc,EAAE;EAAA,IAAAC,KAAA;EACtE,IAAI5B,oBAAoB,CAAC0B,IAAI,CAAC,EAAE;IAC9B7B,OAAO,CAACgC,OAAO,CAACH,IAAI,CAAC;IACrB;EACF;EAEAzB,aAAa,CAAC,IAAI,CAAC;EACnB,IAAME,aAAa,GAAG,IAAI,CAACA,aAAa,CAACU,OAAO;EAEhD,IAAIV,aAAa,IAAI,IAAI,EAAE;IACzB,MAAM,IAAIE,KAAK,CACb,kFACF,CAAC;EACH;EAEA,IAAI,CAAC,IAAI,CAACyB,OAAO,EAAE;IACjB,MAAM,IAAIzB,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEA,IAAIqB,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,EAAE;IACnCvB,aAAa,CAACO,MAAM,CAAC,CAAC;IACtB;EACF;EAEA,IAAMqB,SAAS,GAAG5B,aAAa,CAAC6B,YAAY,CAAC,CAAC;EAE9C,IAAIN,IAAI,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;IAAA,IAAAC,qBAAA,EAAAC,eAAA,EAAAC,sBAAA;IACxB,IAAMC,IAAI,IAAAH,qBAAA,IAAAC,eAAA,GACR,IAAI,CAACG,SAAS,sBAAAF,sBAAA,GAAdD,eAAA,CAAgBI,QAAQ,qBAAxBH,sBAAA,CACII,GAAG,CAAC,UAACC,OAAO,EAAK;MACjB,IAAI,CAACA,OAAO,CAACR,UAAU,CAAC,GAAG,CAAC,EAAE,OAAOQ,OAAO;MAE5C,IAAIA,OAAO,CAACR,UAAU,CAAC,MAAM,CAAC,EAAE;QAAA,IAAAS,gBAAA,EAAAC,qBAAA;QAC9BF,OAAO,GAAGA,OAAO,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9B,IAAMvB,MAAM,IAAAqB,gBAAA,GAAGd,KAAI,CAACU,SAAS,sBAAAK,qBAAA,GAAdD,gBAAA,CAAgBrB,MAAM,qBAAtBsB,qBAAA,CAAyBF,OAAO,CAAC;QAChD,IAAII,KAAK,CAACC,OAAO,CAACzB,MAAM,CAAC,EAAE;UACzB,OAAOA,MAAM,CAAC0B,IAAI,CAAC,GAAG,CAAC;QACzB,CAAC,MAAM;UAAA,IAAAC,kBAAA,EAAAC,aAAA;UACL,QAAAD,kBAAA,GAAO3B,MAAM,qBAAA4B,aAAA,GAAN5B,MAAM,CAAE6B,KAAK,CAAC,GAAG,CAAC,qBAAlBD,aAAA,CAAoBF,IAAI,CAAC,GAAG,CAAC,YAAAC,kBAAA,GAAI,EAAE;QAC5C;MACF,CAAC,MAAM;QAAA,IAAAG,gBAAA,EAAAC,qBAAA;QACLX,OAAO,GAAGA,OAAO,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9B,QAAAO,gBAAA,GAAOvB,KAAI,CAACU,SAAS,sBAAAc,qBAAA,GAAdD,gBAAA,CAAgB9B,MAAM,qBAAtB+B,qBAAA,CAAyBX,OAAO,CAAC;MAC1C;IACF,CAAC,CAAC,CACDY,MAAM,CAACC,OAAO,CAAC,CACfP,IAAI,CAAC,GAAG,CAAC,YAAAb,qBAAA,GAAI,GAAG;IAErBR,IAAI,GAAG3B,OAAO,CAACsC,IAAI,GAAG,KAAK,EAAEX,IAAI,CAAC;EACpC;EAEA,IAAM6B,KAAK,GAAG,IAAI,CAACzB,OAAO,CAAC0B,gBAAgB,CAAE9B,IAAI,EAAE,IAAI,CAACI,OAAO,CAAC2B,MAAM,CAAC;EAEvE,IAAI,CAACF,KAAK,IAAIA,KAAK,CAACG,MAAM,CAACnC,MAAM,KAAK,CAAC,EAAE;IACvCoC,OAAO,CAACC,KAAK,CACX,kEAAkE,GAAGlC,IACvE,CAAC;IACD;EACF;EAEA,QAAQC,KAAK;IACX,KAAK,SAAS;MACZ,OAAOxB,aAAa,CAAC0D,QAAQ,CAACC,wBAAwB,CAACP,KAAK,EAAExB,SAAS,CAAC,CAAC;IAC3E;MACE,OAAO5B,aAAa,CAAC0D,QAAQ,CAACE,qBAAqB,CAACR,KAAK,EAAExB,SAAS,CAAC,CAAC;EAC1E;AACF;AAOA,SAASiC,8BAA8BA,CACrCT,KAAyC,EAEzC;EAAA,IADAlC,MAAwB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAE7B,IAAI,CAACiC,KAAK,EAAE,OAAOlC,MAAM;EAEzB,IAAM4C,SAAS,GAAGV,KAAK,CAACG,MAAM,CAACQ,EAAE,CAAC,CAAC,CAAC,CAAE;EACtC7C,MAAM,CAAC8C,MAAM,GAAGF,SAAS,CAACG,IAAI;EAE9B/C,MAAM,CAACA,MAAM,GAAG4C,SAAS,CAAC5C,MAAM,GAC5BgD,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACN,SAAS,CAAC5C,MAAM,CAAC,CAAC,GAC5C,CAAC,CAAC;EAEN,IAAI4C,SAAS,CAACV,KAAK,EAAE;IACnBS,8BAA8B,CAACC,SAAS,CAACV,KAAK,EAAElC,MAAM,CAACA,MAAM,CAAC;EAChE;EAEA,OAAOgD,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAClD,MAAM,CAAC,CAAC;AAC3C;AAEA,SAAS0C,qBAAqBA,CAACR,KAAkB,EAAExB,SAA0B,EAAE;EAC7E,IAAAyC,qBAAA,GAA2BR,8BAA8B,CAACT,KAAK,CAAC;IAAxDY,MAAM,GAAAK,qBAAA,CAANL,MAAM;IAAE9C,MAAM,GAAAmD,qBAAA,CAANnD,MAAM;EACtB,OAAO;IACLoD,IAAI,EAAE,UAAU;IAChBC,MAAM,EAAE3C,SAAS,CAAC4C,GAAG;IACrBC,OAAO,EAAE;MACPR,IAAI,EAAED,MAAM;MACZ9C,MAAM,EAANA;IACF;EACF,CAAC;AACH;AAEA,SAASyC,wBAAwBA,CAC/BP,KAAkB,EAClBsB,WAA4B,EAEV;EAAA,IAAAC,qBAAA;EAAA,IADlBC,8BAA+C,GAAAzD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGuD,WAAW;EAG7D,IAAMG,KAAK,GAAGzB,KAAK,CAACG,MAAM,CAACQ,EAAE,CAAC,CAAC,CAAC,CAAE;EAGlC,IAAIW,WAAW,CAACJ,IAAI,KAAK,OAAO,IAAII,WAAW,CAACJ,IAAI,KAAK,KAAK,EAAE;IAC9DM,8BAA8B,GAAGF,WAAW;EAC9C;EAEA,IAAMI,YAAY,GAAGJ,WAAW,CAACnB,MAAM,CAACwB,IAAI,CAC1C,UAACC,WAAW;IAAA,OAAKA,WAAW,CAACf,IAAI,KAAKY,KAAK,CAACZ,IAAI;EAAA,CAClD,CAAC;EACD,IAAMgB,cAAc,GAAGP,WAAW,CAACnB,MAAM,CAACmB,WAAW,CAACQ,KAAK,CAAC,KAAKJ,YAAY;EAG7E,IAAID,KAAK,CAACzB,KAAK,IAAI6B,cAAc,IAAIH,YAAY,CAAC1B,KAAK,EAAE;IACvD,OAAOO,wBAAwB,CAC7BkB,KAAK,CAACzB,KAAK,EACX0B,YAAY,CAAC1B,KAAK,EAClBwB,8BACF,CAAC;EACH;EAGA,IAAAO,sBAAA,GAA2BtB,8BAA8B,CAACT,KAAK,CAAC;IAAxDY,MAAM,GAAAmB,sBAAA,CAANnB,MAAM;IAAE9C,MAAM,GAAAiE,sBAAA,CAANjE,MAAM;EAEtB,OAAO;IACLoD,IAAI,EACFM,8BAA8B,CAACN,IAAI,KAAK,OAAO,GAAG,SAAS,GAAG,SAAS;IACzEC,MAAM,GAAAI,qBAAA,GAAEC,8BAA8B,qBAA9BD,qBAAA,CAAgCH,GAAG;IAC3CC,OAAO,EAAE;MACPR,IAAI,EAAED,MAAM;MACZ9C,MAAM,EAANA;IACF;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}