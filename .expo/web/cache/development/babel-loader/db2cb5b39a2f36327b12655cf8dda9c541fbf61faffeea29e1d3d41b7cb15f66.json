{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useNavigationContainerRef } from \"@react-navigation/native\";\nimport { useSyncExternalStore, useMemo, Fragment } from \"react\";\nimport { getRouteInfoFromState } from \"../LocationProvider\";\nimport { deepEqual, getPathDataFromState } from \"../fork/getPathFromState\";\nimport { getLinkingConfig } from \"../getLinkingConfig\";\nimport { getRoutes } from \"../getRoutes\";\nimport { getQualifiedRouteComponent } from \"../useScreens\";\nimport { _internal_maybeHideAsync } from \"../views/Splash\";\nimport { canGoBack, goBack, linkTo, push, replace, setParams } from \"./routing\";\nimport { getSortedRoutes } from \"./sort-routes\";\nexport var RouterStore = function () {\n  function RouterStore() {\n    var _this = this;\n    _classCallCheck(this, RouterStore);\n    this.hasAttemptedToHideSplash = false;\n    this.rootStateSubscribers = new Set();\n    this.storeSubscribers = new Set();\n    this.linkTo = linkTo.bind(this);\n    this.getSortedRoutes = getSortedRoutes.bind(this);\n    this.goBack = goBack.bind(this);\n    this.canGoBack = canGoBack.bind(this);\n    this.push = push.bind(this);\n    this.replace = replace.bind(this);\n    this.setParams = setParams.bind(this);\n    this.subscribeToRootState = function (subscriber) {\n      _this.rootStateSubscribers.add(subscriber);\n      return function () {\n        return _this.rootStateSubscribers.delete(subscriber);\n      };\n    };\n    this.subscribeToStore = function (subscriber) {\n      _this.storeSubscribers.add(subscriber);\n      return function () {\n        return _this.storeSubscribers.delete(subscriber);\n      };\n    };\n    this.snapshot = function () {\n      return _this;\n    };\n    this.rootStateSnapshot = function () {\n      return _this.rootState;\n    };\n    this.routeInfoSnapshot = function () {\n      return _this.routeInfo;\n    };\n  }\n  _createClass(RouterStore, [{\n    key: \"initialize\",\n    value: function initialize(context, navigationRef, initialLocation) {\n      var _this$navigationRefSu,\n        _this2 = this;\n      this.initialState = undefined;\n      this.rootState = undefined;\n      this.nextState = undefined;\n      this.routeInfo = undefined;\n      this.linking = undefined;\n      (_this$navigationRefSu = this.navigationRefSubscription) == null ? void 0 : _this$navigationRefSu.call(this);\n      this.rootStateSubscribers.clear();\n      this.storeSubscribers.clear();\n      this.routeNode = getRoutes(context);\n      this.rootComponent = this.routeNode ? getQualifiedRouteComponent(this.routeNode) : Fragment;\n      if (!this.routeNode && process.env.NODE_ENV === \"production\") {\n        throw new Error(\"No routes found\");\n      }\n      this.navigationRef = navigationRef;\n      if (this.routeNode) {\n        this.linking = getLinkingConfig(this.routeNode);\n        if (initialLocation) {\n          var _this$linking$getStat, _this$linking;\n          this.linking.getInitialURL = function () {\n            return initialLocation.toString();\n          };\n          this.initialState = (_this$linking$getStat = (_this$linking = this.linking).getStateFromPath) == null ? void 0 : _this$linking$getStat.call(_this$linking, initialLocation.pathname + initialLocation.search, this.linking.config);\n        }\n      }\n      if (this.initialState) {\n        this.rootState = this.initialState;\n        this.routeInfo = this.getRouteInfo(this.initialState);\n      } else {\n        this.routeInfo = {\n          unstable_globalHref: \"\",\n          pathname: \"\",\n          params: {},\n          segments: []\n        };\n      }\n      this.navigationRefSubscription = navigationRef.addListener(\"state\", function (data) {\n        var state = data.data.state;\n        if (!_this2.hasAttemptedToHideSplash) {\n          _this2.hasAttemptedToHideSplash = true;\n          requestAnimationFrame(function () {\n            return _internal_maybeHideAsync();\n          });\n        }\n        var shouldUpdateSubscribers = _this2.nextState === state;\n        _this2.nextState = undefined;\n        if (state && state !== _this2.rootState) {\n          store.updateState(state, undefined);\n          shouldUpdateSubscribers = true;\n        }\n        if (shouldUpdateSubscribers) {\n          for (var subscriber of _this2.rootStateSubscribers) {\n            subscriber();\n          }\n        }\n      });\n      for (var subscriber of this.storeSubscribers) {\n        subscriber();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(state) {\n      var nextState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state;\n      store.rootState = state;\n      store.nextState = nextState;\n      var nextRouteInfo = store.getRouteInfo(state);\n      if (!deepEqual(this.routeInfo, nextRouteInfo)) {\n        store.routeInfo = nextRouteInfo;\n      }\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(state) {\n      var _this3 = this;\n      return getRouteInfoFromState(function (state, asPath) {\n        var _this3$linking;\n        return getPathDataFromState(state, _objectSpread(_objectSpread({\n          screens: []\n        }, (_this3$linking = _this3.linking) == null ? void 0 : _this3$linking.config), {}, {\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath\n        }));\n      }, state);\n    }\n  }, {\n    key: \"shouldShowTutorial\",\n    value: function shouldShowTutorial() {\n      return !this.routeNode && process.env.NODE_ENV === \"development\";\n    }\n  }]);\n  return RouterStore;\n}();\nexport var store = new RouterStore();\nexport function useExpoRouter() {\n  return useSyncExternalStore(store.subscribeToStore, store.snapshot, store.snapshot);\n}\nfunction syncStoreRootState() {\n  if (store.navigationRef.isReady()) {\n    var currentState = store.navigationRef.getRootState();\n    if (store.rootState !== currentState) {\n      store.updateState(currentState);\n    }\n  }\n}\nexport function useStoreRootState() {\n  syncStoreRootState();\n  return useSyncExternalStore(store.subscribeToRootState, store.rootStateSnapshot, store.rootStateSnapshot);\n}\nexport function useStoreRouteInfo() {\n  syncStoreRootState();\n  return useSyncExternalStore(store.subscribeToRootState, store.routeInfoSnapshot, store.routeInfoSnapshot);\n}\nexport function useInitializeExpoRouter(context, initialLocation) {\n  var navigationRef = useNavigationContainerRef();\n  useMemo(function () {\n    return store.initialize(context, navigationRef, initialLocation);\n  }, [context, initialLocation]);\n  useExpoRouter();\n  return store;\n}","map":{"version":3,"names":["useNavigationContainerRef","useSyncExternalStore","useMemo","Fragment","getRouteInfoFromState","deepEqual","getPathDataFromState","getLinkingConfig","getRoutes","getQualifiedRouteComponent","_internal_maybeHideAsync","canGoBack","goBack","linkTo","push","replace","setParams","getSortedRoutes","RouterStore","_this","_classCallCheck","hasAttemptedToHideSplash","rootStateSubscribers","Set","storeSubscribers","bind","subscribeToRootState","subscriber","add","delete","subscribeToStore","snapshot","rootStateSnapshot","rootState","routeInfoSnapshot","routeInfo","_createClass","key","value","initialize","context","navigationRef","initialLocation","_this$navigationRefSu","_this2","initialState","undefined","nextState","linking","navigationRefSubscription","call","clear","routeNode","rootComponent","process","env","NODE_ENV","Error","_this$linking$getStat","_this$linking","getInitialURL","toString","getStateFromPath","pathname","search","config","getRouteInfo","unstable_globalHref","params","segments","addListener","data","state","requestAnimationFrame","shouldUpdateSubscribers","store","updateState","arguments","length","nextRouteInfo","_this3","asPath","_this3$linking","_objectSpread","screens","preserveDynamicRoutes","preserveGroups","shouldShowTutorial","useExpoRouter","syncStoreRootState","isReady","currentState","getRootState","useStoreRootState","useStoreRouteInfo","useInitializeExpoRouter"],"sources":["C:/Users/Bartek/react_native_boi/node_modules/expo-router/src/global-state/router-store.tsx"],"sourcesContent":["import {\n  NavigationContainerRefWithCurrent,\n  getPathFromState,\n  useNavigationContainerRef,\n} from \"@react-navigation/native\";\nimport { useSyncExternalStore, useMemo, ComponentType, Fragment } from \"react\";\n\nimport { UrlObject, getRouteInfoFromState } from \"../LocationProvider\";\nimport { RouteNode } from \"../Route\";\nimport { deepEqual, getPathDataFromState } from \"../fork/getPathFromState\";\nimport { ResultState } from \"../fork/getStateFromPath\";\nimport { ExpoLinkingOptions, getLinkingConfig } from \"../getLinkingConfig\";\nimport { getRoutes } from \"../getRoutes\";\nimport { RequireContext } from \"../types\";\nimport { getQualifiedRouteComponent } from \"../useScreens\";\nimport { _internal_maybeHideAsync } from \"../views/Splash\";\nimport { canGoBack, goBack, linkTo, push, replace, setParams } from \"./routing\";\nimport { getSortedRoutes } from \"./sort-routes\";\n\n/**\n * This is the global state for the router. It is used to keep track of the current route, and to provide a way to navigate to other routes.\n *\n * There should only be one instance of this class and be initialized via `useInitializeExpoRouter`\n */\nexport class RouterStore {\n  routeNode!: RouteNode | null;\n  rootComponent!: ComponentType;\n  linking: ExpoLinkingOptions | undefined;\n  private hasAttemptedToHideSplash: boolean = false;\n\n  initialState: ResultState | undefined;\n  rootState: ResultState | undefined;\n  nextState: ResultState | undefined;\n  routeInfo?: UrlObject | undefined;\n\n  navigationRef!: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>;\n  navigationRefSubscription!: () => void;\n\n  rootStateSubscribers = new Set<() => void>();\n  storeSubscribers = new Set<() => void>();\n\n  linkTo = linkTo.bind(this);\n  getSortedRoutes = getSortedRoutes.bind(this);\n  goBack = goBack.bind(this);\n  canGoBack = canGoBack.bind(this);\n  push = push.bind(this);\n  replace = replace.bind(this);\n  setParams = setParams.bind(this);\n\n  initialize(\n    context: RequireContext,\n    navigationRef: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>,\n    initialLocation?: URL\n  ) {\n    // Clean up any previous state\n    this.initialState = undefined;\n    this.rootState = undefined;\n    this.nextState = undefined;\n    this.routeInfo = undefined;\n    this.linking = undefined;\n    this.navigationRefSubscription?.();\n    this.rootStateSubscribers.clear();\n    this.storeSubscribers.clear();\n\n    this.routeNode = getRoutes(context);\n\n    this.rootComponent = this.routeNode\n      ? getQualifiedRouteComponent(this.routeNode)\n      : Fragment;\n\n    // Only error in production, in development we will show the onboarding screen\n    if (!this.routeNode && process.env.NODE_ENV === \"production\") {\n      throw new Error(\"No routes found\");\n    }\n\n    this.navigationRef = navigationRef;\n\n    if (this.routeNode) {\n      this.linking = getLinkingConfig(this.routeNode!);\n\n      if (initialLocation) {\n        this.linking.getInitialURL = () => initialLocation.toString();\n        this.initialState = this.linking.getStateFromPath?.(\n          initialLocation.pathname + initialLocation.search,\n          this.linking.config\n        );\n      }\n    }\n\n    // There is no routeNode, so we will be showing the onboarding screen\n    // In the meantime, just mock the routeInfo\n    if (this.initialState) {\n      this.rootState = this.initialState;\n      this.routeInfo = this.getRouteInfo(this.initialState);\n    } else {\n      this.routeInfo = {\n        unstable_globalHref: \"\",\n        pathname: \"\",\n        params: {},\n        segments: [],\n      };\n    }\n\n    /**\n     * Counter intuitively - this fires AFTER both React Navigations state change and the subsequent paint.\n     * This poses a couple of issues for Expo Router,\n     *   - Ensuring hooks (e.g. useSearchParams()) have data in the initial render\n     *   - Reacting to state changes after a navigation event\n     *\n     * This is why the initial render renders a Fragment and we wait until `onReady()` is called\n     * Additionally, some hooks compare the state from both the store and the navigationRef. If the store it stale,\n     * that hooks will manually update the store.\n     *\n     */\n    this.navigationRefSubscription = navigationRef.addListener(\n      \"state\",\n      (data) => {\n        const state = data.data.state as ResultState;\n\n        if (!this.hasAttemptedToHideSplash) {\n          this.hasAttemptedToHideSplash = true;\n          // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.\n          requestAnimationFrame(() => _internal_maybeHideAsync());\n        }\n\n        let shouldUpdateSubscribers = this.nextState === state;\n        this.nextState = undefined;\n\n        // This can sometimes be undefined when an error is thrown in the Root Layout Route.\n        // Additionally that state may already equal the rootState if it was updated within a hook\n        if (state && state !== this.rootState) {\n          store.updateState(state, undefined);\n          shouldUpdateSubscribers = true;\n        }\n\n        // If the state has changed, or was changed inside a hook we need to update the subscribers\n        if (shouldUpdateSubscribers) {\n          for (const subscriber of this.rootStateSubscribers) {\n            subscriber();\n          }\n        }\n      }\n    );\n\n    for (const subscriber of this.storeSubscribers) {\n      subscriber();\n    }\n  }\n\n  updateState(state: ResultState, nextState = state) {\n    store.rootState = state;\n    store.nextState = nextState;\n\n    const nextRouteInfo = store.getRouteInfo(state);\n\n    if (!deepEqual(this.routeInfo, nextRouteInfo)) {\n      store.routeInfo = nextRouteInfo;\n    }\n  }\n\n  getRouteInfo(state: ResultState) {\n    return getRouteInfoFromState(\n      (state: Parameters<typeof getPathFromState>[0], asPath: boolean) => {\n        return getPathDataFromState(state, {\n          screens: [],\n          ...this.linking?.config,\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath,\n        });\n      },\n      state\n    );\n  }\n\n  // This is only used in development, to show the onboarding screen\n  // In production we should have errored during the initialization\n  shouldShowTutorial() {\n    return !this.routeNode && process.env.NODE_ENV === \"development\";\n  }\n\n  /** Make sure these are arrow functions so `this` is correctly bound */\n  subscribeToRootState = (subscriber: () => void) => {\n    this.rootStateSubscribers.add(subscriber);\n    return () => this.rootStateSubscribers.delete(subscriber);\n  };\n  subscribeToStore = (subscriber: () => void) => {\n    this.storeSubscribers.add(subscriber);\n    return () => this.storeSubscribers.delete(subscriber);\n  };\n  snapshot = () => {\n    return this;\n  };\n  rootStateSnapshot = () => {\n    return this.rootState!;\n  };\n  routeInfoSnapshot = () => {\n    return this.routeInfo!;\n  };\n}\n\nexport const store = new RouterStore();\n\nexport function useExpoRouter() {\n  return useSyncExternalStore(\n    store.subscribeToStore,\n    store.snapshot,\n    store.snapshot\n  );\n}\n\nfunction syncStoreRootState() {\n  if (store.navigationRef.isReady()) {\n    const currentState =\n      store.navigationRef.getRootState() as unknown as ResultState;\n\n    if (store.rootState !== currentState) {\n      store.updateState(currentState);\n    }\n  }\n}\n\nexport function useStoreRootState() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.rootStateSnapshot,\n    store.rootStateSnapshot\n  );\n}\n\nexport function useStoreRouteInfo() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.routeInfoSnapshot,\n    store.routeInfoSnapshot\n  );\n}\n\nexport function useInitializeExpoRouter(\n  context: RequireContext,\n  initialLocation: URL | undefined\n) {\n  const navigationRef = useNavigationContainerRef();\n  useMemo(\n    () => store.initialize(context, navigationRef, initialLocation),\n    [context, initialLocation]\n  );\n  useExpoRouter();\n  return store;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}