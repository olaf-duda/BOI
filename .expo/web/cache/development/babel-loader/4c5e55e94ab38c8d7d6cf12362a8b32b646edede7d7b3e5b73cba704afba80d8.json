{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nexport function getRouteInfoFromState(getPathFromState, state) {\n  var _getPathFromState = getPathFromState(state, false),\n    path = _getPathFromState.path;\n  var qualified = getPathFromState(state, true);\n  return _objectSpread({\n    unstable_globalHref: path,\n    isIndex: isIndexPath(state),\n    pathname: path.split(\"?\")[\"0\"]\n  }, getNormalizedStatePath(qualified));\n}\nfunction isIndexPath(state) {\n  var _state$index;\n  var route = state.routes[(_state$index = state.index) != null ? _state$index : state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n  if (route.params && \"screen\" in route.params) {\n    return route.params.screen === \"index\";\n  }\n  return false;\n}\nexport function getNormalizedStatePath(_ref) {\n  var statePath = _ref.path,\n    params = _ref.params;\n  var _statePath$split = statePath.split(\"?\"),\n    _statePath$split2 = _slicedToArray(_statePath$split, 1),\n    pathname = _statePath$split2[0];\n  return {\n    segments: pathname.split(\"/\").filter(Boolean).map(decodeURIComponent),\n    params: Object.entries(params).reduce(function (prev, _ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n      if (Array.isArray(value)) {\n        prev[key] = value.map(decodeURIComponent);\n      } else {\n        prev[key] = decodeURIComponent(value);\n      }\n      return prev;\n    }, {})\n  };\n}","map":{"version":3,"names":["getRouteInfoFromState","getPathFromState","state","_getPathFromState","path","qualified","_objectSpread","unstable_globalHref","isIndex","isIndexPath","pathname","split","getNormalizedStatePath","_state$index","route","routes","index","length","params","screen","_ref","statePath","_statePath$split","_statePath$split2","_slicedToArray","segments","filter","Boolean","map","decodeURIComponent","Object","entries","reduce","prev","_ref2","_ref3","key","value","Array","isArray"],"sources":["C:/Users/Bartek/react_native_boi/node_modules/expo-router/src/LocationProvider.tsx"],"sourcesContent":["import { State } from \"./fork/getPathFromState\";\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: SearchParams;\n  segments: string[];\n  isIndex: boolean;\n};\n\nexport function getRouteInfoFromState(\n  getPathFromState: (\n    state: State,\n    asPath: boolean\n  ) => { path: string; params: any },\n  state: State\n): UrlObject {\n  const { path } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n  return {\n    // TODO: This may have a predefined origin attached in the future.\n    unstable_globalHref: path,\n    isIndex: isIndexPath(state),\n    pathname: path.split(\"?\")[\"0\"],\n    ...getNormalizedStatePath(qualified),\n  };\n}\n\nfunction isIndexPath(state: State): boolean {\n  const route = state.routes[state.index ?? state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n  // router.params is typed as 'object', so this usual syntax is to please TypeScript\n  if (route.params && \"screen\" in route.params) {\n    return route.params.screen === \"index\";\n  }\n  return false;\n}\n\n// TODO: Split up getPathFromState to return all this info at once.\nexport function getNormalizedStatePath({\n  path: statePath,\n  params,\n}: {\n  path: string;\n  params: any;\n}): Pick<UrlObject, \"segments\" | \"params\"> {\n  const [pathname] = statePath.split(\"?\");\n  return {\n    // Strip empty path at the start\n    segments: pathname.split(\"/\").filter(Boolean).map(decodeURIComponent),\n    // TODO: This is not efficient, we should generate based on the state instead\n    // of converting to string then back to object\n    params: Object.entries(params).reduce((prev, [key, value]) => {\n      if (Array.isArray(value)) {\n        prev[key] = value.map(decodeURIComponent);\n      } else {\n        prev[key] = decodeURIComponent(value as string);\n      }\n      return prev;\n    }, {} as SearchParams),\n  };\n}\n"],"mappings":";;;;AAYA,OAAO,SAASA,qBAAqBA,CACnCC,gBAGkC,EAClCC,KAAY,EACD;EACX,IAAAC,iBAAA,GAAiBF,gBAAgB,CAACC,KAAK,EAAE,KAAK,CAAC;IAAvCE,IAAI,GAAAD,iBAAA,CAAJC,IAAI;EACZ,IAAMC,SAAS,GAAGJ,gBAAgB,CAACC,KAAK,EAAE,IAAI,CAAC;EAC/C,OAAAI,aAAA;IAEEC,mBAAmB,EAAEH,IAAI;IACzBI,OAAO,EAAEC,WAAW,CAACP,KAAK,CAAC;IAC3BQ,QAAQ,EAAEN,IAAI,CAACO,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG;EAAC,GAC3BC,sBAAsB,CAACP,SAAS,CAAC;AAExC;AAEA,SAASI,WAAWA,CAACP,KAAY,EAAW;EAAA,IAAAW,YAAA;EAC1C,IAAMC,KAAK,GAAGZ,KAAK,CAACa,MAAM,EAAAF,YAAA,GAACX,KAAK,CAACc,KAAK,YAAAH,YAAA,GAAIX,KAAK,CAACa,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC;EAClE,IAAIH,KAAK,CAACZ,KAAK,EAAE;IACf,OAAOO,WAAW,CAACK,KAAK,CAACZ,KAAK,CAAC;EACjC;EAEA,IAAIY,KAAK,CAACI,MAAM,IAAI,QAAQ,IAAIJ,KAAK,CAACI,MAAM,EAAE;IAC5C,OAAOJ,KAAK,CAACI,MAAM,CAACC,MAAM,KAAK,OAAO;EACxC;EACA,OAAO,KAAK;AACd;AAGA,OAAO,SAASP,sBAAsBA,CAAAQ,IAAA,EAMK;EAAA,IALnCC,SAAS,GAAAD,IAAA,CAAfhB,IAAI;IACJc,MAAM,GAAAE,IAAA,CAANF,MAAM;EAKN,IAAAI,gBAAA,GAAmBD,SAAS,CAACV,KAAK,CAAC,GAAG,CAAC;IAAAY,iBAAA,GAAAC,cAAA,CAAAF,gBAAA;IAAhCZ,QAAQ,GAAAa,iBAAA;EACf,OAAO;IAELE,QAAQ,EAAEf,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC,CAACe,MAAM,CAACC,OAAO,CAAC,CAACC,GAAG,CAACC,kBAAkB,CAAC;IAGrEX,MAAM,EAAEY,MAAM,CAACC,OAAO,CAACb,MAAM,CAAC,CAACc,MAAM,CAAC,UAACC,IAAI,EAAAC,KAAA,EAAmB;MAAA,IAAAC,KAAA,GAAAX,cAAA,CAAAU,KAAA;QAAhBE,GAAG,GAAAD,KAAA;QAAEE,KAAK,GAAAF,KAAA;MACtD,IAAIG,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;QACxBJ,IAAI,CAACG,GAAG,CAAC,GAAGC,KAAK,CAACT,GAAG,CAACC,kBAAkB,CAAC;MAC3C,CAAC,MAAM;QACLI,IAAI,CAACG,GAAG,CAAC,GAAGP,kBAAkB,CAACQ,KAAe,CAAC;MACjD;MACA,OAAOJ,IAAI;IACb,CAAC,EAAE,CAAC,CAAiB;EACvB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}