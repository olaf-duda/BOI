{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport EXPO_ROUTER_IMPORT_MODE from \"./import-mode\";\nimport { getNameFromFilePath, matchDeepDynamicRouteName, matchDynamicName, matchGroupName, removeSupportedExtensions, stripGroupSegmentsFromPath, stripInvisibleSegmentsFromPath } from \"./matchers\";\nexport function getRecursiveTree(files) {\n  var tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var file of files) {\n    var parts = file.normalizedName.split(\"/\");\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(`Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`);\n        }\n        return 1;\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      if (_loop()) continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nfunction assertDeprecatedFormat(tree) {\n  for (var child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith(\"_layout\")) {\n      var ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(`Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``);\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes) {\n  return nodes.map(function (node) {\n    return treeNodeToRouteNode(node);\n  }).flat().filter(Boolean);\n}\nexport function generateDynamicFromSegment(name) {\n  var deepDynamicName = matchDeepDynamicRouteName(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : matchDynamicName(name);\n  return dynamicName ? {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  } : null;\n}\nexport function generateDynamic(name) {\n  var description = name.split(\"/\").map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nfunction collapseRouteSegments(route) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = matchGroupName(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded != null && loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction folderNodeToRouteNode(_ref) {\n  var name = _ref.name,\n    children = _ref.children;\n  if (!children.length) {\n    return null;\n  }\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join(\"/\")\n    });\n  }));\n}\nfunction fileNodeToRouteNode(tree) {\n  var name = tree.name,\n    node = tree.node,\n    children = tree.children;\n  if (!node) throw new Error(\"node must be defined\");\n  var dynamic = generateDynamic(name);\n  var clones = extrapolateGroupRoutes(name, node.contextKey);\n  clones.delete(name);\n  var output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  };\n  if (clones.size) {\n    return _toConsumableArray(clones).map(function (clone) {\n      return applyDefaultInitialRouteName(_objectSpread(_objectSpread({}, output), {}, {\n        contextKey: node.contextKey.replace(output.route, clone),\n        route: clone\n      }));\n    });\n  }\n  return [applyDefaultInitialRouteName({\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  })];\n}\nfunction extrapolateGroupRoutes(route, contextKey) {\n  var routes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  var match = matchGroupName(route);\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n  var groups = match == null ? void 0 : match.split(\",\");\n  var groupsSet = new Set(groups);\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${contextKey}\".`);\n  }\n  if (groups.length === 1) {\n    routes.add(route);\n    return routes;\n  }\n  for (var group of groups) {\n    extrapolateGroupRoutes(route.replace(match, group.trim()), contextKey, routes);\n  }\n  return routes;\n}\nfunction treeNodeToRouteNode(tree) {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n  return folderNodeToRouteNode(tree);\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : contextModule.keys();\n  var nodes = files.map(function (key) {\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        if (EXPO_ROUTER_IMPORT_MODE === \"sync\") {\n          var _contextModule;\n          if (!((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n            return null;\n          }\n        }\n      }\n      var node = {\n        loadRoute: function loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key\n      };\n      return node;\n    } catch (error) {\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === \"\" && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode) {\n  var routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\nfunction processKeys(files, options) {\n  var ignore = options.ignore;\n  return files.filter(function (file) {\n    return !(ignore != null && ignore.some(function (pattern) {\n      return pattern.test(file);\n    }));\n  });\n}\nexport function assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return removeSupportedExtensions(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      filename = _ref3[0],\n      count = _ref3[1];\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\nexport function getRoutes(contextModule, options) {\n  var route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n  appendUnmatchedRoute(route);\n  return route;\n}\nexport function getRoutesAsync(_x, _x2) {\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction _getRoutesAsync() {\n  _getRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var route = yield getExactRoutesAsync(contextModule, options);\n    if (!route) {\n      return null;\n    }\n    appendSitemapRoute(route);\n    appendUnmatchedRoute(route);\n    return route;\n  });\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  return ignore;\n}\nexport function getExactRoutes(contextModule, options) {\n  var treeNodes = contextModuleToTree(contextModule, options);\n  var route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\nfunction contextModuleToTree(contextModule, options) {\n  var allowed = processKeys(contextModule.keys(), _objectSpread(_objectSpread({}, options), {}, {\n    ignore: getIgnoreList(options)\n  }));\n  assertDuplicateRoutes(allowed);\n  var files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\nexport function getExactRoutesAsync(_x3, _x4) {\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction _getExactRoutesAsync() {\n  _getExactRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var treeNodes = contextModuleToTree(contextModule, options);\n    var route = treeNodesToRootRoute(treeNodes);\n    return route || null;\n  });\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length || routes.children.some(function (route) {\n    return route.route === \"_sitemap\";\n  })) {\n    return routes;\n  }\n  var _require = require(\"./views/Sitemap\"),\n    Sitemap = _require.Sitemap,\n    getNavOptions = _require.getNavOptions;\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require(\"./views/Unmatched\").Unmatched\n        };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{\n        name: \"404\",\n        deep: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\nexport function getUserDefinedDeepDynamicRoute(routes) {\n  for (var route of (_routes$children = routes.children) != null ? _routes$children : []) {\n    var _routes$children;\n    if (route.generated) continue;\n    var opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    var isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if (matchGroupName(route.route)) {\n      var child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\nfunction withOptionalRootLayout(routes) {\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require(\"./views/Navigator\").DefaultNavigator\n      };\n    },\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}","map":{"version":3,"names":["EXPO_ROUTER_IMPORT_MODE","getNameFromFilePath","matchDeepDynamicRouteName","matchDynamicName","matchGroupName","removeSupportedExtensions","stripGroupSegmentsFromPath","stripInvisibleSegmentsFromPath","getRecursiveTree","files","tree","name","children","parents","node","file","parts","normalizedName","split","currentNode","_loop","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","concat","_toConsumableArray","push","process","env","NODE_ENV","assertDeprecatedFormat","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deepDynamicName","dynamicName","deep","generateDynamic","description","segment","collapseRouteSegments","route","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","_node$children","_getDefaultInitialRou","groupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","_loaded$unstable_sett","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","_objectSpread","folderNodeToRouteNode","_ref","join","fileNodeToRouteNode","dynamic","clones","extrapolateGroupRoutes","delete","output","size","clone","routes","arguments","Set","match","add","groups","groupsSet","group","trim","contextModuleToFileNodes","contextModule","keys","key","_contextModule","default","error","console","warn","hasCustomRootLayoutNode","treeNodesToRootRoute","treeNode","withOptionalRootLayout","processKeys","options","ignore","some","pattern","test","assertDuplicateRoutes","filenames","duplicates","filename","reduce","acc","Object","entries","forEach","_ref2","_ref3","_slicedToArray","count","getRoutes","getExactRoutes","appendSitemapRoute","appendUnmatchedRoute","getRoutesAsync","_x","_x2","_getRoutesAsync","apply","_asyncToGenerator","getExactRoutesAsync","getIgnoreList","_options$ignore","treeNodes","contextModuleToTree","allowed","_x3","_x4","_getExactRoutesAsync","_require","require","Sitemap","getNavOptions","generated","internal","userDefinedDynamicRoute","getUserDefinedDeepDynamicRoute","Unmatched","_routes$children","opaqueRoute","isDeepDynamic","DefaultNavigator"],"sources":["C:/Users/Bartek/react_native_boi/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from \"./Route\";\nimport EXPO_ROUTER_IMPORT_MODE from \"./import-mode\";\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n  stripInvisibleSegmentsFromPath,\n} from \"./matchers\";\nimport type { RequireContext } from \"./types\";\n\nexport type FileNode = Pick<RouteNode, \"contextKey\" | \"loadRoute\"> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split(\"/\");\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (\n      child.node &&\n      child.children.length &&\n      !child.node.normalizedName.endsWith(\"_layout\")\n    ) {\n      const ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node))\n    .flat()\n    .filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(\n  name: string\n): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode[\"dynamic\"] {\n  const description = name\n    .split(\"/\")\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find(\n    (node) => collapseRouteSegments(node.route) === name\n  );\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName\n    ? getDefaultInitialRoute(node, groupName)?.route\n    : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded?.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName =\n      loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction folderNodeToRouteNode({\n  name,\n  children,\n}: TreeNode): RouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join(\"/\"),\n      };\n    })\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error(\"node must be defined\");\n\n  const dynamic = generateDynamic(name);\n\n  const clones = extrapolateGroupRoutes(name, node.contextKey);\n  clones.delete(name);\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic,\n  };\n\n  if (clones.size) {\n    return [...clones].map((clone) =>\n      applyDefaultInitialRouteName({\n        ...output,\n        contextKey: node.contextKey.replace(output.route, clone),\n        route: clone,\n      })\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    }),\n  ];\n}\n\nfunction extrapolateGroupRoutes(\n  route: string,\n  contextKey: string,\n  routes: Set<string> = new Set()\n): Set<string> {\n  const match = matchGroupName(route);\n\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n\n  const groups = match?.split(\",\");\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(\n      `Array syntax cannot contain duplicate group name \"${groups}\" in \"${contextKey}\".`\n    );\n  }\n\n  if (groups.length === 1) {\n    routes.add(route);\n    return routes;\n  }\n\n  for (const group of groups) {\n    extrapolateGroupRoutes(\n      route.replace(match, group.trim()),\n      contextKey,\n      routes\n    );\n  }\n\n  return routes;\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n\n  return folderNodeToRouteNode(tree);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n        // filter the missing routes.\n        if (EXPO_ROUTER_IMPORT_MODE === \"sync\") {\n          if (!contextModule(key)?.default) {\n            return null;\n          }\n        }\n      }\n      const node: FileNode = {\n        loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key,\n      };\n\n      return node;\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (\n    route.route === \"\" &&\n    route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce((acc, filename) => {\n      acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const route = getExactRoutes(contextModule, options);\n\n  // If there is no route, return an empty route.\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nexport async function getRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const route = await getExactRoutesAsync(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [\n    /^\\.\\/\\+html\\.[tj]sx?$/,\n    ...(options?.ignore ?? []),\n  ];\n  return ignore;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\n\nexport async function getExactRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === \"_sitemap\")\n  ) {\n    return routes;\n  }\n  const { Sitemap, getNavOptions } = require(\"./views/Sitemap\");\n  routes.children.push({\n    loadRoute() {\n      return { default: Sitemap, getNavOptions };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require(\"./views/Unmatched\").Unmatched };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{ name: \"404\", deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(\n  routes: RouteNode\n): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    if (route.generated) continue;\n    const opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    const isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(routes: RouteNode[] | null): RouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (\n        require(\"./views/Navigator\") as typeof import(\"./views/Navigator\")\n      ).DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}