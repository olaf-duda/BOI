{"ast":null,"code":"\"use strict\";\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withSubscription = exports.observe = exports.isDisabled = exports.setDisabled = exports.addIgnorePatterns = exports.getIgnorePatterns = exports.dismiss = exports.clearErrors = exports.clearWarnings = exports.setSelectedLog = exports.clear = exports.symbolicateLogLazy = exports.retrySymbolicateLogNow = exports.symbolicateLogNow = exports.addException = exports.addLog = exports.isMessageIgnored = exports.isLogBoxErrorMessage = exports.reportUnexpectedLogBoxError = exports.reportLogBoxError = void 0;\nvar React = __importStar(require(\"react\"));\nvar NativeLogBox_1 = __importDefault(require(\"../modules/NativeLogBox\"));\nvar parseErrorStack_1 = __importDefault(require(\"../modules/parseErrorStack\"));\nvar LogBoxLog_1 = require(\"./LogBoxLog\");\nvar LogContext_1 = require(\"./LogContext\");\nvar parseLogBoxLog_1 = require(\"./parseLogBoxLog\");\nvar observers = new Set();\nvar ignorePatterns = new Set();\nvar logs = new Set();\nvar updateTimeout = null;\nvar _isDisabled = false;\nvar _selectedIndex = -1;\nvar LOGBOX_ERROR_MESSAGE = \"An error was thrown when attempting to render log messages via LogBox.\";\nfunction getNextState() {\n  return {\n    logs: logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\nfunction reportLogBoxError(error, componentStack) {\n  var ExceptionsManager = require(\"../modules/ExceptionsManager\");\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\nexports.reportLogBoxError = reportLogBoxError;\nfunction reportUnexpectedLogBoxError(error, componentStack) {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\nexports.reportUnexpectedLogBoxError = reportUnexpectedLogBoxError;\nfunction isLogBoxErrorMessage(message) {\n  return typeof message === \"string\" && message.includes(LOGBOX_ERROR_MESSAGE);\n}\nexports.isLogBoxErrorMessage = isLogBoxErrorMessage;\nfunction isMessageIgnored(message) {\n  for (var pattern of ignorePatterns) {\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === \"string\" && message.includes(pattern)) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.isMessageIgnored = isMessageIgnored;\nfunction setImmediateShim(callback) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(function () {\n      updateTimeout = null;\n      var nextState = getNextState();\n      observers.forEach(function (_ref) {\n        var observer = _ref.observer;\n        return observer(nextState);\n      });\n    });\n  }\n}\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n  var lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n  if (newLog.level === \"fatal\") {\n    var OPTIMISTIC_WAIT_TIME = 1000;\n    var _addPendingLog = function addPendingLog() {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      _addPendingLog = null;\n    };\n    var optimisticTimeout = setTimeout(function () {\n      if (_addPendingLog) {\n        _addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate(\"component\");\n    newLog.symbolicate(\"stack\", function (status) {\n      if (_addPendingLog && status !== \"PENDING\") {\n        _addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== \"PENDING\") {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === \"syntax\") {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\nfunction addLog(log) {\n  var errorForStackTrace = new Error();\n  setImmediate(function () {\n    try {\n      var stack = (0, parseErrorStack_1.default)(errorForStackTrace === null || errorForStackTrace === void 0 ? void 0 : errorForStackTrace.stack);\n      appendNewLog(new LogBoxLog_1.LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack: stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\nexports.addLog = addLog;\nfunction addException(error) {\n  setImmediate(function () {\n    try {\n      appendNewLog(new LogBoxLog_1.LogBoxLog((0, parseLogBoxLog_1.parseLogBoxException)(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\nexports.addException = addException;\nfunction symbolicateLogNow(type, log) {\n  log.symbolicate(type, function () {\n    handleUpdate();\n  });\n}\nexports.symbolicateLogNow = symbolicateLogNow;\nfunction retrySymbolicateLogNow(type, log) {\n  log.retrySymbolicate(type, function () {\n    handleUpdate();\n  });\n}\nexports.retrySymbolicateLogNow = retrySymbolicateLogNow;\nfunction symbolicateLogLazy(type, log) {\n  log.symbolicate(type);\n}\nexports.symbolicateLogLazy = symbolicateLogLazy;\nfunction clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\nexports.clear = clear;\nfunction setSelectedLog(proposedNewIndex) {\n  var oldIndex = _selectedIndex;\n  var newIndex = proposedNewIndex;\n  var logArray = Array.from(logs);\n  var index = logArray.length - 1;\n  while (index >= 0) {\n    if (logArray[index].level === \"syntax\") {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox_1.default) {\n    setTimeout(function () {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox_1.default.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox_1.default.hide();\n      }\n    }, 0);\n  }\n}\nexports.setSelectedLog = setSelectedLog;\nfunction clearWarnings() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== \"warn\";\n  });\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\nexports.clearWarnings = clearWarnings;\nfunction clearErrors() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== \"error\" && log.level !== \"fatal\";\n  });\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\nexports.clearErrors = clearErrors;\nfunction dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\nexports.dismiss = dismiss;\nfunction getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\nexports.getIgnorePatterns = getIgnorePatterns;\nfunction addIgnorePatterns(patterns) {\n  var existingSize = ignorePatterns.size;\n  patterns.forEach(function (pattern) {\n    if (pattern instanceof RegExp) {\n      for (var existingPattern of ignorePatterns) {\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  logs = new Set(Array.from(logs).filter(function (log) {\n    return !isMessageIgnored(log.message.content);\n  }));\n  handleUpdate();\n}\nexports.addIgnorePatterns = addIgnorePatterns;\nfunction setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\nexports.setDisabled = setDisabled;\nfunction isDisabled() {\n  return _isDisabled;\n}\nexports.isDisabled = isDisabled;\nfunction observe(observer) {\n  var subscription = {\n    observer: observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe: function unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\nexports.observe = observe;\nfunction withSubscription(WrappedComponent) {\n  var LogBoxStateSubscription = function (_React$Component) {\n    _inherits(LogBoxStateSubscription, _React$Component);\n    var _super = _createSuper(LogBoxStateSubscription);\n    function LogBoxStateSubscription() {\n      var _this;\n      _classCallCheck(this, LogBoxStateSubscription);\n      _this = _super.apply(this, arguments);\n      _this.state = {\n        logs: new Set(),\n        isDisabled: false,\n        hasError: false,\n        selectedLogIndex: -1\n      };\n      _this._handleDismiss = function () {\n        var _this$state = _this.state,\n          selectedLogIndex = _this$state.selectedLogIndex,\n          stateLogs = _this$state.logs;\n        var logsArray = Array.from(stateLogs);\n        if (selectedLogIndex != null) {\n          if (logsArray.length - 1 <= 0) {\n            setSelectedLog(-1);\n          } else if (selectedLogIndex >= logsArray.length - 1) {\n            setSelectedLog(selectedLogIndex - 1);\n          }\n          dismiss(logsArray[selectedLogIndex]);\n        }\n      };\n      _this._handleMinimize = function () {\n        setSelectedLog(-1);\n      };\n      _this._handleSetSelectedLog = function (index) {\n        setSelectedLog(index);\n      };\n      return _this;\n    }\n    _createClass(LogBoxStateSubscription, [{\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(err, errorInfo) {\n        reportLogBoxError(err, errorInfo.componentStack);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (this.state.hasError) {\n          return null;\n        }\n        return React.createElement(LogContext_1.LogContext.Provider, {\n          value: {\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs)\n          }\n        }, this.props.children, React.createElement(WrappedComponent, null));\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n        this._subscription = observe(function (data) {\n          _this2.setState(data);\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        if (this._subscription != null) {\n          this._subscription.unsubscribe();\n        }\n      }\n    }], [{\n      key: \"getDerivedStateFromError\",\n      value: function getDerivedStateFromError() {\n        return {\n          hasError: true\n        };\n      }\n    }]);\n    return LogBoxStateSubscription;\n  }(React.Component);\n  return LogBoxStateSubscription;\n}\nexports.withSubscription = withSubscription;","map":{"version":3,"names":["React","__importStar","require","NativeLogBox_1","__importDefault","parseErrorStack_1","LogBoxLog_1","LogContext_1","parseLogBoxLog_1","observers","Set","ignorePatterns","logs","updateTimeout","_isDisabled","_selectedIndex","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","handleException","exports","reportUnexpectedLogBoxError","message","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","setImmediateShim","callback","global","setImmediate","setTimeout","handleUpdate","nextState","forEach","_ref","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","default","LogBoxLog","isComponentError","addException","parseLogBoxException","loggingError","symbolicateLogNow","type","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","getIgnorePatterns","addIgnorePatterns","patterns","existingSize","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","withSubscription","WrappedComponent","LogBoxStateSubscription","_React$Component","_inherits","_super","_createSuper","_this","_classCallCheck","state","hasError","_handleDismiss","_this$state","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog","_createClass","key","componentDidCatch","err","errorInfo","render","createElement","LogContext","Provider","props","children","componentDidMount","_this2","_subscription","data","setState","componentWillUnmount","getDerivedStateFromError","Component"],"sources":["C:\\Users\\Bartek\\react_native_boi\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxData.tsx"],"sourcesContent":["/**\n * Copyright (c) Evan Bacon.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from \"react\";\n\nimport NativeLogBox from \"../modules/NativeLogBox\";\nimport parseErrorStack from \"../modules/parseErrorStack\";\nimport { LogBoxLog, StackType } from \"./LogBoxLog\";\nimport type { LogLevel } from \"./LogBoxLog\";\nimport { LogContext } from \"./LogContext\";\nimport { parseLogBoxException } from \"./parseLogBoxLog\";\nimport type {\n  Message,\n  Category,\n  ComponentStack,\n  ExtendedExceptionData,\n} from \"./parseLogBoxLog\";\n\nexport type LogBoxLogs = Set<LogBoxLog>;\n\nexport type LogData = {\n  level: LogLevel;\n  message: Message;\n  category: Category;\n  componentStack: ComponentStack;\n};\n\ntype ExtendedError = any;\n\nexport type Observer = (options: {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  selectedLogIndex: number;\n}) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\nexport type WarningInfo = {\n  finalFormat: string;\n  forceDialogImmediately: boolean;\n  suppressDialog_LEGACY: boolean;\n  suppressCompletely: boolean;\n  monitorEvent: string | null;\n  monitorListVersion: number;\n  monitorSampleRate: number;\n};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype Props = object;\n\ntype State = {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  hasError: boolean;\n  selectedLogIndex: number;\n};\n\nconst observers: Set<{ observer: Observer } & any> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout:\n  | null\n  | ReturnType<typeof setImmediate>\n  | ReturnType<typeof setTimeout> = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nconst LOGBOX_ERROR_MESSAGE =\n  \"An error was thrown when attempting to render log messages via LogBox.\";\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(\n  error: ExtendedError,\n  componentStack?: string\n): void {\n  const ExceptionsManager = require(\"../modules/ExceptionsManager\");\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\n\nexport function reportUnexpectedLogBoxError(\n  error: ExtendedError,\n  componentStack?: string\n): void {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === \"string\" && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === \"string\" && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction setImmediateShim(callback: () => void) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({ observer }) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog): void {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === \"fatal\") {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // symbolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: null | (() => void) = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    // TODO: HANDLE THIS\n    newLog.symbolicate(\"component\");\n\n    newLog.symbolicate(\"stack\", (status) => {\n      if (addPendingLog && status !== \"PENDING\") {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== \"PENDING\") {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === \"syntax\") {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        })\n      );\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.retrySymbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type);\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === \"syntax\") {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== \"warn\");\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter(\n    (log) => log.level !== \"error\" && log.level !== \"fatal\"\n  );\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function getIgnorePatterns(): IgnorePattern[] {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(patterns: IgnorePattern[]): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(\n    Array.from(logs).filter((log) => !isMessageIgnored(log.message.content))\n  );\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = { observer };\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\nexport function withSubscription(\n  WrappedComponent: React.FC<object>\n): React.Component<object> {\n  class LogBoxStateSubscription extends React.Component<\n    React.PropsWithChildren<Props>,\n    State\n  > {\n    static getDerivedStateFromError() {\n      return { hasError: true };\n    }\n\n    componentDidCatch(err: Error, errorInfo: { componentStack: string } & any) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription?: Subscription;\n\n    state = {\n      logs: new Set<LogBoxLog>(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render() {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show any fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <LogContext.Provider\n          value={{\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs),\n          }}\n        >\n          {this.props.children}\n          <WrappedComponent />\n        </LogContext.Provider>\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe((data) => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const { selectedLogIndex, logs: stateLogs } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  // @ts-expect-error\n  return LogBoxStateSubscription;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}