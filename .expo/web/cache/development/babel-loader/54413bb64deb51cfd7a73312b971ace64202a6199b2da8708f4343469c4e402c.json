{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { useDeprecated } from \"../useDeprecated\";\nvar globalStack = [];\nexport function SplashScreen() {\n  useGlobalSplash();\n  useDeprecated(\"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\");\n  return null;\n}\nfunction useGlobalSplash() {\n  var stack = React.useRef(null);\n  React.useEffect(function () {\n    stack.current = SplashScreen._pushEntry();\n    return function () {\n      if (stack.current) {\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\nSplashScreen.hideAsync = function () {\n  forceHideAsync();\n  globalStack.length = 0;\n};\nvar _userControlledAutoHideEnabled = false;\nvar _preventAutoHideAsyncInvoked = false;\nexport var _internal_preventAutoHideAsync = function _internal_preventAutoHideAsync() {\n  var _ErrorUtils;\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  if (Platform.OS !== \"web\" && (_ErrorUtils = ErrorUtils) != null && _ErrorUtils.getGlobalHandler) {\n    var originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler(function (error, isFatal) {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\nexport var _internal_maybeHideAsync = function _internal_maybeHideAsync() {\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\nfunction forceHideAsync() {\n  return _forceHideAsync.apply(this, arguments);\n}\nfunction _forceHideAsync() {\n  _forceHideAsync = _asyncToGenerator(function* () {\n    return SplashModule.hideAsync().catch(function (error) {\n      if (_preventAutoHideAsyncInvoked && error.message.includes(\"No native splash screen registered for \")) {\n        return;\n      }\n      throw error;\n    });\n  });\n  return _forceHideAsync.apply(this, arguments);\n}\nSplashScreen.preventAutoHideAsync = function () {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\nSplashScreen._pushEntry = function () {\n  var entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\nSplashScreen._popEntry = function (entry) {\n  var index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};","map":{"version":3,"names":["SplashModule","nanoid","React","Platform","useDeprecated","globalStack","SplashScreen","useGlobalSplash","stack","useRef","useEffect","current","_pushEntry","_popEntry","hideAsync","forceHideAsync","length","_userControlledAutoHideEnabled","_preventAutoHideAsyncInvoked","_internal_preventAutoHideAsync","_ErrorUtils","OS","ErrorUtils","getGlobalHandler","originalHandler","setGlobalHandler","error","isFatal","preventAutoHideAsync","_internal_maybeHideAsync","_forceHideAsync","apply","arguments","_asyncToGenerator","catch","message","includes","entry","push","index","indexOf","splice"],"sources":["C:/Users/Bartek/react_native_boi/node_modules/expo-router/src/views/Splash.tsx"],"sourcesContent":["import * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport { Platform } from \"react-native\";\n\nimport { useDeprecated } from \"../useDeprecated\";\n\nconst globalStack: string[] = [];\n\n/**\n * A stack based component for keeping the splash screen visible.\n * Useful for stacked requests that need to be completed before the app is ready.\n * After all instances have been unmounted, the splash screen will be hidden.\n *\n * @example\n * ```tsx\n * function App() {\n *   const [isLoading, setIsLoading] = React.useState(true);\n *\n *   if (isLoading) {\n *     return <SplashScreen />\n *   }\n *\n *   return <Text>Ready!</Text>\n * }\n * ```\n */\nexport function SplashScreen() {\n  useGlobalSplash();\n  useDeprecated(\n    \"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\"\n  );\n  return null;\n}\n\nfunction useGlobalSplash() {\n  const stack = React.useRef<string | null>(null);\n\n  React.useEffect(() => {\n    // Create a stack entry on component mount\n    stack.current = SplashScreen._pushEntry();\n    return () => {\n      if (stack.current) {\n        // Update on component unmount\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\n\nSplashScreen.hideAsync = () => {\n  forceHideAsync();\n  globalStack.length = 0;\n};\n\nlet _userControlledAutoHideEnabled = false;\nlet _preventAutoHideAsyncInvoked = false;\n\n// Expo Router uses this internal method to ensure that we can detect if the user\n// has explicitly opted into preventing the splash screen from hiding. This means\n// they will also explicitly hide it. If they don't, we will hide it for them after\n// the navigation render completes.\nexport const _internal_preventAutoHideAsync = () => {\n  // Memoize, this should only be called once.\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.\n  if (Platform.OS !== \"web\" && ErrorUtils?.getGlobalHandler) {\n    const originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler((error, isFatal) => {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\n\nexport const _internal_maybeHideAsync = () => {\n  // If the user has explicitly opted into preventing the splash screen from hiding,\n  // we should not hide it for them. This is often used for animated splash screens.\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\n\nasync function forceHideAsync() {\n  return SplashModule.hideAsync().catch((error: any) => {\n    // Hide this very unfortunate error.\n    if (\n      // Only throw the error is something unexpected happened.\n      _preventAutoHideAsyncInvoked &&\n      error.message.includes(\"No native splash screen registered for \")\n    ) {\n      return;\n    }\n    throw error;\n  });\n}\n\nSplashScreen.preventAutoHideAsync = () => {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\n\nSplashScreen._pushEntry = (): any => {\n  const entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\n\nSplashScreen._popEntry = (entry: string) => {\n  const index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};\n\n// TODO: Add some detection for if the splash screen is visible\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}